/*
 * This file belongs to the FastSID implementation of VirtualC64,
 * an adaption of the code used in VICE 3.1, the Versatile Commodore Emulator.
 *
 * Original code written by
 *  Teemu Rantanen <tvr@cs.hut.fi>
 *
 * Adapted for VirtualC64 by
 *  Dirk Hoffmann
 */
/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307  USA.
 *
 */


#ifndef FASTSIDVOICE_H
#define FASTSIDVOICE_H

#include "VirtualComponent.h"

// Waveform types
#define FASTSID_TRIANGLE 0x10
#define FASTSID_SAW      0x20
#define FASTSID_PULSE    0x40
#define FASTSID_NOISE    0x80

// Filter types
#define FASTSID_HIGH_PASS 0x40
#define FASTSID_BAND_PASS 0x20
#define FASTSID_LOW_PASS  0x10

// ADSR state (Attack, Decay, Sustain, Release)
#define FASTSID_ATTACK   0
#define FASTSID_DECAY    1
#define FASTSID_SUSTAIN  2
#define FASTSID_RELEASE  3
#define FASTSID_IDLE     4

// Noise magic

// The noise waveform of the SID is generated by a simple 23 bit LFSR.
// On shifting, bit 0 is filled with bit 22 EXOR bit 17.
#define NSHIFT(v, n) \
(((v) << (n))    \
| ((((v) >> (23 - (n))) ^ (v >> (18 - (n)))) & ((1 << (n)) - 1)))

#define NVALUE(v)                                   \
(noiseLSB[v & 0xff] | noiseMID[(v >> 8) & 0xff] \
| noiseMSB[(v >> 16) & 0xff])

#define NSEED 0x7ffff8


class FastVoice : public VirtualComponent {
    
    friend class FastSID;
    
private:
    
    //! @brief   Wave tables
    //! @details The first index determines the chip model (0 = old, 1 = new).
    static uint16_t wavetable10[2][4096];
    static uint16_t wavetable20[2][4096];
    static uint16_t wavetable30[2][4096];
    static uint16_t wavetable40[2][8192];
    static uint16_t wavetable50[2][8192];
    static uint16_t wavetable60[2][8192];
    static uint16_t wavetable70[2][8192];
    
    //! @brief   Noise tables
    static uint8_t noiseMSB[256];
    static uint8_t noiseMID[256];
    static uint8_t noiseLSB[256];
    
    //! @brief   The SID voice which is represented by this object (1,2, or 3)
    uint8_t nr;

    //! @brief   Pointer to parent SID object
    class FastSID *fastsid;
    
    //! @brief   Pointer to previous voice
    FastVoice *prev;
    
    //! @brief   Pointer to SID registers controlling this voice
    uint8_t *sidreg;
    

    //
    // Wave tables
    //
    
    //! @brief   Pointer to the active wavetable
    uint16_t *wavetable;
    
    //! @brief   Wavetable offset
    /*! @details This 32-bit offset is added to the counter before
     *           referencing the wavetable. It is used when other
     *           waveforms are combined with pulse
     */
    uint32_t waveTableOffset;
    
    //! @brief   Counter value
    uint32_t waveTableCounter;
    
    //! @brief   Counter steps
    /*! @details After each sample, the counter is incremented by this amount.
     */
    uint32_t step;
    
    //! @brief   Set to true if the oscillator should ring modulate
    bool ringmod;
    
    //
    // Waveform generator
    //
    
    //! @brief   Current envelope phase (ATTACK, DECAY, SUSTAIN, RELEASE, or IDLE)
    uint8_t adsrm;
    
    //! @brief   31-bit adsr counter
    uint32_t adsr;
    
    //! @brief   adsr counter step per sample
    int32_t adsrInc;
    
    //! @brief   adsr sustain level comparision value
    uint32_t adsrCmp;
    
    //
    // Noise generator
    //
    
    //! @brief   Noise shift register
    /*! @details The Noise waveform is created using a 23-bit pseudo-random
     *           sequence generator (Linear Feedback Shift Register, LSFR)
     */
    uint32_t lsfr;
    
    //
    // Filter
    //
    
    //! @brief   Filter related variables
    signed char filterIO;
    uint8_t filterType;
    float filterLow;
    float filterRef;
    float filterDy;
    float filterResDy;
    
public:
    
    //! @brief    Constructor
    FastVoice();
    
    //! @brief    Destructor
    ~FastVoice();
    
    //! @functiongroup Methods from VirtualComponent
    void reset();
    void didLoadFromBuffer(uint8_t **buffer) { updateWaveTablePtr(); }
    
    //! @brief    Initializes the wave tables
    /*! @details  Needs to be called once prior to using this class
     */
    static void initWaveTables();
    
    //! @brief    Initialize
    //! @details  Needs to be called once for each voice object
    void init(FastSID *owner, unsigned voiceNr, FastVoice *prevVoice);

    //! @brief    Updates the wavetable pointer
    void updateWaveTablePtr();

    //! @brief    Updates internal data structures
    //! @details  This method is called on each voice related register change
    void updateInternals(bool gateBitFlipped);

    //! @brief  Sets the current filter type
    void setFilterType(uint8_t type);

    //! @brief  Change ADSR state and all related variables
    void set_adsr(uint8_t fm);
    
    //! @brief ADSR counter triggered state change
    void trigger_adsr();
    
    // 15-bit oscillator value
    uint32_t doosc();
    
    //! @brief Apply filter effect
    void applyFilter();
    
    //
    // Querying configuration items
    //
        
    //! @brief   Returns the currently set oscillator frequency
    uint16_t frequency() { return HI_LO(sidreg[0x01], sidreg[0x00]); }

    //! @brief   Returns the pulse width of the pulse waveform
    /*! @details The pulse width is a 12-bit number which linearly controls
     *           the pulse width (duty cycle) of the pulse waveform.
     */
    uint16_t pulseWidth() { return ((sidreg[3] & 0x0F) << 8) | sidreg[0x02]; }

    //! @brief   Returns the GATE bit for this voice
    /*! @details The gate bit controls the Envelope Generator. When this
     *           bit is set to a one, the Envelope Generator is Gated
     *           (triggered) and the attack/decay/sustain cycle is initiated.
     *           When the bit is reset to a zero, the release cycle begins.
     */
    bool gateBit() { return sidreg[0x04] & 0x01; }
    
    //! @brief   Returns the SYNC bit for this voice
    /*! @details If this bit is set, hard sync effects are produced.
     *           Hard sync is where one waveform plays at its own frequency,
     *           but gets reset back to its start every time the second waveform
     *           loops. It is responsible for the rising modulating sound in
     *           Ben Daglish's Wilderness music from The Last Ninja and the
     *           ludicrous intro noise in Martin Galway's Roland's Rat Race music.
     */
    bool syncBit() { return (sidreg[0x04] & 0x02) != 0; }
    
    //! @brief   Returns the RING MOD bit of the control register
    /*! @details The RING MOD bit, when set to a one, replaces the
     *           Triangle waveform output of Oscillator 1 with a
     *           “Ring Modulated” combination of Oscillators 1 and 3.
     */
    bool ringModBit() { return (sidreg[0x04] & 0x04) != 0; }
    
    //! @brief   Returns the TEST bit of the control register
    /*! @details The TEST bit, when set to a one, resets and
     *           locks Oscillator 1 at zero until the TEST bit
     *           is cleared. The Noise waveform output of
     *           Oscillator 1 is also reset and the Pulse waveform
     *           output is held at a DC level.
     */
    bool testBit() { return (sidreg[0x04] & 0x08) != 0; }

    //! @brief   Returns the waveform bits of the control register
    uint8_t waveform() { return sidreg[0x04] & 0xF0; }
    
    //! @brief   Returns the attack rate for the envelope generator
    /*! @details The attack rate is a 4 bit value which determines how rapidly
     *           the output of the voice rises from zero to peak amplitude when
     *           the envelope generator is gated.
     */
    uint8_t attackRate() { return sidreg[0x05] >> 4; }

    //! @brief   Returns the decay rate for the envelope generator
    /*! @details The decay cycle follows the attack cycle and the decay rate
     *           determines how rapidly the output falls from the peak amplitude
     *           to the selected sustain level.
     */
    uint8_t decayRate() { return sidreg[0x05] & 0x0F; }

    //! @brief   Returns the decay rate for the envelope generator
    /*! @details The sustain cycle follows the decay cycle and the output of
     *           the voice will remain at the selected sustain amplitude as
     *           long as the gate bit remains set. The sustain levels range
     *           from zero to peak amplitude in 16 linear steps, with a sustain
     *           value of 0 selecting zero amplitude and a sustain value of 15
     *           selecting the peak amplitude.
     *           A sustain value of 8 would cause the voice to sustain at an
     *           amplitude one-half the peak amplitude reached by the attack
     *           cycle.
     */
    uint8_t sustainRate() { return sidreg[0x06] >> 4; }

    //! @brief   Returns the release rate for the envelope generator
    /*! @details The release cycle follows the sustain cycle when the Gate bit is
     *           reset to zero. At this time, the output of Voice 1 will fall
     *           from the sustain amplitude to zero amplitude at the selected
     *           release rate. The 16 release rates are identical to the decay
     *           rates.
     */
    uint8_t releaseRate() { return sidreg[0x06] & 0x0F; }
};

#endif
